// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stakes.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createStake = `-- name: CreateStake :one
INSERT INTO stakes (user_id, token_id, amount, apy, end_date, auto_compound)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, token_id, amount, apy, start_date, end_date, status, auto_compound, rewards_claimed, created_at, updated_at
`

type CreateStakeParams struct {
	UserID       pgtype.UUID      `json:"user_id"`
	TokenID      pgtype.UUID      `json:"token_id"`
	Amount       pgtype.Numeric   `json:"amount"`
	Apy          pgtype.Numeric   `json:"apy"`
	EndDate      pgtype.Timestamp `json:"end_date"`
	AutoCompound pgtype.Bool      `json:"auto_compound"`
}

// internal/db/queries/stakes.sql
func (q *Queries) CreateStake(ctx context.Context, arg CreateStakeParams) (Stake, error) {
	row := q.db.QueryRow(ctx, createStake,
		arg.UserID,
		arg.TokenID,
		arg.Amount,
		arg.Apy,
		arg.EndDate,
		arg.AutoCompound,
	)
	var i Stake
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenID,
		&i.Amount,
		&i.Apy,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.AutoCompound,
		&i.RewardsClaimed,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStakeByID = `-- name: GetStakeByID :one
SELECT s.id, s.user_id, s.token_id, s.amount, s.apy, s.start_date, s.end_date, s.status, s.auto_compound, s.rewards_claimed, s.created_at, s.updated_at, t.symbol, t.name
FROM stakes s
JOIN tokens t ON s.token_id = t.id
WHERE s.id = $1
`

type GetStakeByIDRow struct {
	ID             uuid.UUID        `json:"id"`
	UserID         pgtype.UUID      `json:"user_id"`
	TokenID        pgtype.UUID      `json:"token_id"`
	Amount         pgtype.Numeric   `json:"amount"`
	Apy            pgtype.Numeric   `json:"apy"`
	StartDate      pgtype.Timestamp `json:"start_date"`
	EndDate        pgtype.Timestamp `json:"end_date"`
	Status         pgtype.Text      `json:"status"`
	AutoCompound   pgtype.Bool      `json:"auto_compound"`
	RewardsClaimed pgtype.Numeric   `json:"rewards_claimed"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Symbol         string           `json:"symbol"`
	Name           string           `json:"name"`
}

func (q *Queries) GetStakeByID(ctx context.Context, id uuid.UUID) (GetStakeByIDRow, error) {
	row := q.db.QueryRow(ctx, getStakeByID, id)
	var i GetStakeByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenID,
		&i.Amount,
		&i.Apy,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.AutoCompound,
		&i.RewardsClaimed,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Symbol,
		&i.Name,
	)
	return i, err
}

const getTotalStakedValue = `-- name: GetTotalStakedValue :one
SELECT COALESCE(SUM(s.amount * a.market_price), 0)::decimal as total_value
FROM stakes s
JOIN assets a ON s.token_id = a.token_id
WHERE s.status = 'active'
`

func (q *Queries) GetTotalStakedValue(ctx context.Context) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getTotalStakedValue)
	var total_value pgtype.Numeric
	err := row.Scan(&total_value)
	return total_value, err
}

const getUserStakes = `-- name: GetUserStakes :many
SELECT s.id, s.user_id, s.token_id, s.amount, s.apy, s.start_date, s.end_date, s.status, s.auto_compound, s.rewards_claimed, s.created_at, s.updated_at, t.symbol, t.name
FROM stakes s
JOIN tokens t ON s.token_id = t.id
WHERE s.user_id = $1 AND s.status = 'active'
ORDER BY s.created_at DESC
`

type GetUserStakesRow struct {
	ID             uuid.UUID        `json:"id"`
	UserID         pgtype.UUID      `json:"user_id"`
	TokenID        pgtype.UUID      `json:"token_id"`
	Amount         pgtype.Numeric   `json:"amount"`
	Apy            pgtype.Numeric   `json:"apy"`
	StartDate      pgtype.Timestamp `json:"start_date"`
	EndDate        pgtype.Timestamp `json:"end_date"`
	Status         pgtype.Text      `json:"status"`
	AutoCompound   pgtype.Bool      `json:"auto_compound"`
	RewardsClaimed pgtype.Numeric   `json:"rewards_claimed"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	Symbol         string           `json:"symbol"`
	Name           string           `json:"name"`
}

func (q *Queries) GetUserStakes(ctx context.Context, userID pgtype.UUID) ([]GetUserStakesRow, error) {
	rows, err := q.db.Query(ctx, getUserStakes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserStakesRow{}
	for rows.Next() {
		var i GetUserStakesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TokenID,
			&i.Amount,
			&i.Apy,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.AutoCompound,
			&i.RewardsClaimed,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Symbol,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unstake = `-- name: Unstake :exec
UPDATE stakes 
SET status = 'unstaked', end_date = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND user_id = $2
`

type UnstakeParams struct {
	ID     uuid.UUID   `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) Unstake(ctx context.Context, arg UnstakeParams) error {
	_, err := q.db.Exec(ctx, unstake, arg.ID, arg.UserID)
	return err
}

const updateStakeRewards = `-- name: UpdateStakeRewards :exec
UPDATE stakes 
SET rewards_claimed = rewards_claimed + $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateStakeRewardsParams struct {
	ID             uuid.UUID      `json:"id"`
	RewardsClaimed pgtype.Numeric `json:"rewards_claimed"`
}

func (q *Queries) UpdateStakeRewards(ctx context.Context, arg UpdateStakeRewardsParams) error {
	_, err := q.db.Exec(ctx, updateStakeRewards, arg.ID, arg.RewardsClaimed)
	return err
}
