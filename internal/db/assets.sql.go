// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assets.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAssetMetrics = `-- name: GetAssetMetrics :one
SELECT 
    COALESCE(SUM(total_value_locked), 0) as total_tvl,
    COUNT(DISTINCT token_id) as active_tokens,
    COUNT(*) as total_assets
FROM assets
`

type GetAssetMetricsRow struct {
	TotalTvl     interface{} `json:"total_tvl"`
	ActiveTokens int64       `json:"active_tokens"`
	TotalAssets  int64       `json:"total_assets"`
}

func (q *Queries) GetAssetMetrics(ctx context.Context) (GetAssetMetricsRow, error) {
	row := q.db.QueryRow(ctx, getAssetMetrics)
	var i GetAssetMetricsRow
	err := row.Scan(&i.TotalTvl, &i.ActiveTokens, &i.TotalAssets)
	return i, err
}

const getTokenList = `-- name: GetTokenList :many
SELECT t.id, t.symbol, t.name, t.contract_address, t.decimals, t.is_active, t.created_at, a.market_price, a.price_change_24h
FROM tokens t
LEFT JOIN assets a ON t.id = a.token_id
WHERE t.is_active = true
ORDER BY t.symbol
`

type GetTokenListRow struct {
	ID              pgtype.UUID      `json:"id"`
	Symbol          string           `json:"symbol"`
	Name            string           `json:"name"`
	ContractAddress pgtype.Text      `json:"contract_address"`
	Decimals        pgtype.Int4      `json:"decimals"`
	IsActive        pgtype.Bool      `json:"is_active"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	MarketPrice     pgtype.Numeric   `json:"market_price"`
	PriceChange24h  pgtype.Numeric   `json:"price_change_24h"`
}

func (q *Queries) GetTokenList(ctx context.Context) ([]GetTokenListRow, error) {
	rows, err := q.db.Query(ctx, getTokenList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTokenListRow{}
	for rows.Next() {
		var i GetTokenListRow
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Name,
			&i.ContractAddress,
			&i.Decimals,
			&i.IsActive,
			&i.CreatedAt,
			&i.MarketPrice,
			&i.PriceChange24h,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAssetPrice = `-- name: UpdateAssetPrice :exec
INSERT INTO assets (token_id, market_price, price_change_24h, volume_24h, recorded_at)
VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)
ON CONFLICT (token_id) 
DO UPDATE SET 
    market_price = EXCLUDED.market_price,
    price_change_24h = EXCLUDED.price_change_24h,
    volume_24h = EXCLUDED.volume_24h,
    recorded_at = EXCLUDED.recorded_at
`

type UpdateAssetPriceParams struct {
	TokenID        pgtype.UUID    `json:"token_id"`
	MarketPrice    pgtype.Numeric `json:"market_price"`
	PriceChange24h pgtype.Numeric `json:"price_change_24h"`
	Volume24h      pgtype.Numeric `json:"volume_24h"`
}

// internal/db/queries/assets.sql
func (q *Queries) UpdateAssetPrice(ctx context.Context, arg UpdateAssetPriceParams) error {
	_, err := q.db.Exec(ctx, updateAssetPrice,
		arg.TokenID,
		arg.MarketPrice,
		arg.PriceChange24h,
		arg.Volume24h,
	)
	return err
}
