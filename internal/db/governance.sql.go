// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: governance.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const castVote = `-- name: CastVote :one
INSERT INTO user_votes (user_id, proposal_id, vote_power, vote_choice)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, proposal_id) 
DO UPDATE SET vote_power = EXCLUDED.vote_power, vote_choice = EXCLUDED.voice_choice
RETURNING id, user_id, proposal_id, vote_power, vote_choice, voted_at
`

type CastVoteParams struct {
	UserID     pgtype.UUID    `json:"user_id"`
	ProposalID pgtype.UUID    `json:"proposal_id"`
	VotePower  pgtype.Numeric `json:"vote_power"`
	VoteChoice string         `json:"vote_choice"`
}

func (q *Queries) CastVote(ctx context.Context, arg CastVoteParams) (UserVote, error) {
	row := q.db.QueryRow(ctx, castVote,
		arg.UserID,
		arg.ProposalID,
		arg.VotePower,
		arg.VoteChoice,
	)
	var i UserVote
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProposalID,
		&i.VotePower,
		&i.VoteChoice,
		&i.VotedAt,
	)
	return i, err
}

const createProposal = `-- name: CreateProposal :one
INSERT INTO governance_proposals (
    title, description, proposer_id, proposal_type, 
    voting_end, quorum, threshold
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, title, description, proposer_id, proposal_type, status, voting_start, voting_end, quorum, threshold, for_votes, against_votes, abstain_votes, total_votes, created_at, updated_at
`

type CreateProposalParams struct {
	Title        string           `json:"title"`
	Description  string           `json:"description"`
	ProposerID   pgtype.UUID      `json:"proposer_id"`
	ProposalType string           `json:"proposal_type"`
	VotingEnd    pgtype.Timestamp `json:"voting_end"`
	Quorum       pgtype.Numeric   `json:"quorum"`
	Threshold    pgtype.Numeric   `json:"threshold"`
}

// internal/db/queries/governance.sql
func (q *Queries) CreateProposal(ctx context.Context, arg CreateProposalParams) (GovernanceProposal, error) {
	row := q.db.QueryRow(ctx, createProposal,
		arg.Title,
		arg.Description,
		arg.ProposerID,
		arg.ProposalType,
		arg.VotingEnd,
		arg.Quorum,
		arg.Threshold,
	)
	var i GovernanceProposal
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ProposerID,
		&i.ProposalType,
		&i.Status,
		&i.VotingStart,
		&i.VotingEnd,
		&i.Quorum,
		&i.Threshold,
		&i.ForVotes,
		&i.AgainstVotes,
		&i.AbstainVotes,
		&i.TotalVotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getActiveProposals = `-- name: GetActiveProposals :many
SELECT id, title, description, proposer_id, proposal_type, status, voting_start, voting_end, quorum, threshold, for_votes, against_votes, abstain_votes, total_votes, created_at, updated_at FROM governance_proposals 
WHERE status = 'active' AND voting_end > CURRENT_TIMESTAMP
ORDER BY created_at DESC
`

func (q *Queries) GetActiveProposals(ctx context.Context) ([]GovernanceProposal, error) {
	rows, err := q.db.Query(ctx, getActiveProposals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GovernanceProposal{}
	for rows.Next() {
		var i GovernanceProposal
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.ProposerID,
			&i.ProposalType,
			&i.Status,
			&i.VotingStart,
			&i.VotingEnd,
			&i.Quorum,
			&i.Threshold,
			&i.ForVotes,
			&i.AgainstVotes,
			&i.AbstainVotes,
			&i.TotalVotes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProposalByID = `-- name: GetProposalByID :one
SELECT id, title, description, proposer_id, proposal_type, status, voting_start, voting_end, quorum, threshold, for_votes, against_votes, abstain_votes, total_votes, created_at, updated_at FROM governance_proposals WHERE id = $1
`

func (q *Queries) GetProposalByID(ctx context.Context, id pgtype.UUID) (GovernanceProposal, error) {
	row := q.db.QueryRow(ctx, getProposalByID, id)
	var i GovernanceProposal
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.ProposerID,
		&i.ProposalType,
		&i.Status,
		&i.VotingStart,
		&i.VotingEnd,
		&i.Quorum,
		&i.Threshold,
		&i.ForVotes,
		&i.AgainstVotes,
		&i.AbstainVotes,
		&i.TotalVotes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserVotes = `-- name: GetUserVotes :many
SELECT id, user_id, proposal_id, vote_power, vote_choice, voted_at FROM user_votes WHERE user_id = $1
`

func (q *Queries) GetUserVotes(ctx context.Context, userID pgtype.UUID) ([]UserVote, error) {
	rows, err := q.db.Query(ctx, getUserVotes, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserVote{}
	for rows.Next() {
		var i UserVote
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ProposalID,
			&i.VotePower,
			&i.VoteChoice,
			&i.VotedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProposalVotes = `-- name: UpdateProposalVotes :exec
UPDATE governance_proposals 
SET 
    for_votes = $2,
    against_votes = $3,
    abstain_votes = $4,
    total_votes = $5,
    status = $6,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateProposalVotesParams struct {
	ID           pgtype.UUID    `json:"id"`
	ForVotes     pgtype.Numeric `json:"for_votes"`
	AgainstVotes pgtype.Numeric `json:"against_votes"`
	AbstainVotes pgtype.Numeric `json:"abstain_votes"`
	TotalVotes   pgtype.Numeric `json:"total_votes"`
	Status       pgtype.Text    `json:"status"`
}

func (q *Queries) UpdateProposalVotes(ctx context.Context, arg UpdateProposalVotesParams) error {
	_, err := q.db.Exec(ctx, updateProposalVotes,
		arg.ID,
		arg.ForVotes,
		arg.AgainstVotes,
		arg.AbstainVotes,
		arg.TotalVotes,
		arg.Status,
	)
	return err
}
